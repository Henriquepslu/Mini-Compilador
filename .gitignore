import re

# -----------------------------
# Analisador Léxico (Lexer)
# -----------------------------

# Tuplas (Tipo do Token, Valor do Token)
def lexer(codigo):
    TOKEN_TYPES = [
        ('NUMBER',   r'\d+'),        # Números inteiros
        ('PLUS',     r'\+'),         # Mais
        ('MINUS',    r'\-'),         # Menos
        ('MUL',      r'\*'),         # Multiplicação
        ('DIV',      r'\/'),         # Divisão
        ('LPAREN',   r'\('),         # Parêntese esquerdo
        ('RPAREN',   r'\)'),         # Parêntese direito
        ('WHITESPACE', r'\s+'),       # Ignorar espaços
        ('MISMATCH', r'.'),          # Qualquer outro caractere (erro)
    ]
    
    # Cria uma grande regex com todos os tipos
    regex = '|'.join(f'(?P<{name}>{pattern})' for name, pattern in TOKEN_TYPES)
    tokens = []
    
    for mo in re.finditer(regex, codigo):
        tipo = mo.lastgroup
        valor = mo.group()
        
        if tipo == 'WHITESPACE':
            continue  # Ignora espaços
        elif tipo == 'MISMATCH':
            raise Exception(f"Erro Léxico: Caractere inesperado '{valor}'")
        else:
            # Armazena o token (ex: 'NUMBER', '123')
            # No seu parser, você só precisa do valor, então vamos manter simples
            tokens.append(valor) 
            
    return tokens

# -----------------------------
# Analisador Sintático + Interpretador
# -----------------------------
class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0

    def eat(self, esperado=None):
        if self.pos >= len(self.tokens):
            raise Exception("Fim inesperado da expressão")
        token = self.tokens[self.pos]
        self.pos += 1
        if esperado and token != esperado:
            raise Exception(f"Esperado '{esperado}' mas encontrado '{token}'")
        return token

    def fator(self):
        token = self.eat()
        if token.isdigit():
            return int(token)
        elif token == '(':
            expr = self.expressao()
            self.eat(')')  # deve fechar parêntese
            return expr
        else:
            raise Exception(f"Token inesperado: '{token}'")

    def termo(self):
        result = self.fator()
        while self.pos < len(self.tokens) and self.tokens[self.pos] in ('*', '/'):
            op = self.eat()
            right = self.fator()
            if op == '*':
                result *= right
            else:
                if right == 0:
                    raise Exception("Erro: divisão por zero")
                result /= right
        return result

    def expressao(self):
        result = self.termo()
        while self.pos < len(self.tokens) and self.tokens[self.pos] in ('+', '-'):
            op = self.eat()
            right = self.termo()
            if op == '+':
                result += right
            else:
                result -= right
        return result


# -----------------------------
# Função Principal (CLI)
# -----------------------------
if __name__ == "__main__":
    print("=== Mini Compilador de Expressões Matemáticas ===")
    print("Digite expressões (ex: 2 + 3 * (4 - 1)) ou 'sair' para encerrar.")

    while True:
        codigo = input("\n>>> ")
        if codigo.lower() == "sair":
            print("Encerrando compilador...")
            break
        try:
            tokens = lexer(codigo)
            parser = Parser(tokens)
            resultado = parser.expressao()

            # Se ainda sobrar tokens, é erro
            if parser.pos < len(tokens):
                raise Exception("Tokens extras encontrados após a expressão")

            print("Resultado:", resultado)
        except Exception as e:
            print("⚠️ Erro:", e)


# -----------------------------
# Testes Automáticos
# -----------------------------
def rodar_testes():
    casos = {
        "2+3": 5,
        "10 - 4": 6,
        "2 * 3 + 4": 10,
        "2 + 3 * 4": 14,
        "(2 + 3) * 4": 20,
        "10 / 2": 5,
        "10 / (5 - 5)": "Erro",   # divisão por zero
        "2 +": "Erro",            # expressão incompleta
        "(2+3": "Erro",           # parêntese não fechado
    }

    print("\n=== Rodando Testes Automáticos ===")
    for expr, esperado in casos.items():
        try:
            tokens = lexer(expr)
            parser = Parser(tokens)
            resultado = parser.expressao()
            if parser.pos < len(tokens):
                raise Exception("Tokens extras")
            ok = (resultado == esperado)
        except:
            resultado = "Erro"
            ok = (esperado == "Erro")

        print(f"Teste: {expr:10} | Esperado: {esperado} | Obtido: {resultado} | {'✅ OK' if ok else '❌ Falhou'}")

# Descomente a linha abaixo para rodar os testes direto:
# rodar_testes()
